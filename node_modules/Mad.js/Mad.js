var serialport = require('serialport');
var Mad = function() {};
var isReady = false;
//
var commandQueue = [];
//
var port;
//
Mad.prototype.log = function() {
    console.log('MAD TANKZ');
};
//
Mad.prototype.connect = function(portName, callback) {
    callback = callback || 0;
    port = new serialport(portName, {
        baudRate: 115200,
        parser: serialport.parsers.readline('\n')
    }, function(err) {
        if (err) {
            console.error(err);
            callback(err);
        } else {
            console.log('Port Open');

            port.on('data', function(data) {
                _handleSerial(data, port)
            });
            //_sendCommandsFromQueue();
            if (callback) {
                callback();
            }
        }
    });
    console.log("Connecting");
};
//
Mad.prototype.disconnect = function(callback) {
    callback = callback || 0;
    if (port.isOpen()) {
        port.close(function(err) {
            if (err) {
                console.error(err);
            } else {
                if (callback) {
                    callback();
                }
            }
        });
        console.log("Disconnecting");
    } else {
        console.error("Port is not open");
    }
};
//
Mad.prototype.addToQueue = function(code) {
    commandQueue.push(code);
    //console.log("Adding to Queue");
};
/*Mad.prototype.receiveData = function () {
    console.log("Receiving Data");
};*/
//
module.exports = new Mad();

function _handleSerial(data, port) {
    if (port != undefined) {
        console.info("Handling Serial");
        console.log(data);
        if (data.substring(0, 3) == "$:D") {
            console.log("got $:D");
            port.write('ADCAFCHPA', function(err) {
                if (err) {
                    console.error("Trying to write PSK to port but " + err);
                } else {
                    //console.info('code written');
                }
            });
        } else if (data[0] == '>') {
            isReady = true;
            console.info("Awaiting Command");
            _sendCommandsFromQueue(port);
        }

    } else {
        console.error("Define Port First");
    }
};

function _sendCommandsFromQueue(port) {
    if (isReady) {
        var senderID = setInterval(function() {
            _sendFirstCommand(port, senderID);
        }, 500);
    } else {
        console.error("Error: Port Not Ready");
    }
};

function _sendFirstCommand(port, senderID) {
    if (commandQueue.length != 0 && isReady) {
        port.write(commandQueue[0], function(err) {
            if (err) {
                console.error(err);
            } else {
                _leftShift();
                isReady = false;
            }
        });
    } else {
        clearInterval(senderID);
    }

}

function _leftShift() {
    for (var i = 0; i < commandQueue.length; i++) {
        if (i != commandQueue.length - 1) {
            commandQueue[i] = commandQueue[i + 1];
        } else {
            commandQueue.splice(commandQueue.length - 1, 1);
        }
    }
}
